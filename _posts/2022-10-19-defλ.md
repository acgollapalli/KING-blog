---
layout: post
title: defλ
---


# Introduction

Let&rsquo;s define some primitives for a preliminary lisp (and associate some symbols while we&rsquo;re at it).

We need:

-   cons (ζ)
-   car (α)
-   cdr (ω) (or should this be β??)
-   nil (∅) and true (⊤)
-   eq (=)
-   cond (χ)
-   quote (&rsquo;)

We can use those to define:

-   eval (Ξ)
-   lambda (λ)
-   map (↦)
-   apply (Λ)

In order to get there, we&rsquo;re going to have to define some preliminaries:


## Preliminaries: Types and Tags

We&rsquo;re going to use [tagged pointers](https://drmeister.wordpress.com/2015/05/16/tagged-pointers-and-immediate-fixnums-characters-and-single-floats-in-clasp/) in order to know what kind of thing (or *type*) our pointer is pointing to, right now we&rsquo;re only going to define a few:

<!-- This HTML table template is generated by emacs 27.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      Pointer&nbsp;Type&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      Pointer&nbsp;tag
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      #b000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      procedure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      #b001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      cons&nbsp;cell&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      #b011&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      #b010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

Now why do we have to have a procedure tag in our pointers? Because we&rsquo;re leaving the door open for an (optional) complication to lisp evaluation. Here&rsquo;s an example:

This is what happens in most lisps when you do this:

    (eval '(1 (+ 1 1) (+ 1 2))) => ERROR: SOMETHING SOMETHING '1' is not a function

And here is what I personally think SHOULD happen:

    (eval '(1 (+ 1 1) (+ 1 2))) => '(1 2 3)

Now, a pointer to a general object, or to something that you treat as a literal, or can&rsquo;t otherwise evaluate, will contain a 0 as the first significant bit (bit 0). As such, the proposed evaluation model would know not to attempt to apply it to a set of arguments. This is subject to change, and may not work, or may be useless. But we&rsquo;ll stick with it for now.


## Preliminaries: Functional Arguments and Procedure Calls

Let&rsquo;s look at an actual example of the kind of thing we&rsquo;d like to write:

    (defλ some-fn
      [x0 x1 x2 x3 & x4]
      (some-stuff x1 x3)
      (compute-return-value x0 x4))

Becomes something like:

        .text
        .global some-fn
    some-fn:
        /* store frame pointer and return address on stack */
        stp x29, x30 [sp, #-32]!
        /* store stack pointer as new frame pointer */
        mov x29, [sp]
    
        /* <evaluation of arguments goes here> */
    
        /* store all the arguments on the stack*/
        stp x0, x1 [sp, #-32]!
        stp x2, x3 [sp, #-32]!
        str x4 [sp, #-16]
    
        /* getting the arguments for some-stuff and calling it */
        ldr x0, [sp], #64         // get x1 (second arg)
        ldr x1, [sp], #32         // get x3 (fourth arg)
        bl some-stuff             // call some-stuff
    
        /* getting the arguments for compute-return-value and calling it */
        ldr x0, [sp], #80         // get x0 (first arg)
        ldr x1, [sp], #16         // get x4 (& args)
        bl compute-return-value   // call compute-return-value
    
        /* pointer to return value is placed in x0 by compute-return-value */
    
        ldp x29, x30, [sp], #112 /* get back frame pointer and return address */
        ret /* return to point in x30 */

[This resource](https://diveintosystems.org/book/C9-ARM64/functions.html) was very helpful in understanding how one might handle procedure calls.


# cons (ζ)

Let&rsquo;s start simple, the absolute simplest we can get: A cons pair.


## What&rsquo;s a Cons Pair?

In any lisp, the core method of constructing data, the core primitive of all data structures, is the cons pair. See [SICP Ch. 2](https://sarabander.github.io/sicp/html/Chapter-2.xhtml#Chapter-2).

    (cons 'a 'b) ;;=> ('a . 'b)

It&rsquo;s typically denoted with a period in between the two objects like so `(<object-a> . <object-b>)`

Typically, a cons pair can depicted in a box and pointer diagram like this<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>:

![img](https://raw.githubusercontent.com/sarabander/sicp/master/html/fig/chap2/Fig2.2e.std.svg)

-   A piece of data (the first part of the pair)
-   Another piece of data (the second part of the pair)
-   The pointers to two pieces of data, which constitute the actual constructed object of a cons pair

All a cons pair really is just two pointers. So in memory we just have to put two things:

1.  The pointer to the first object.
2.  The pointer to the second object

Now it&rsquo;s kind of a magical thing that you can use these pairs to generate lists, and trees, and numerical representations, and all sorts of crazy things! For instance, here&rsquo;s how you represent lists:

![img](https://raw.githubusercontent.com/sarabander/sicp/master/html/fig/chap2/Fig2.4e.std.svg)

It&rsquo;s just:

    (cons 1 (cons 2 (cons 3 (cons 4 nil))))

And that becomes:

    '(1 2 3 4)

Amazing, right!?

So how do we actually translate that out to the machine?


## What is a Cons Pair to Your Computer? And what is cons?

A cons pair is a pair of pointers. That&rsquo;s it. It takes 128 bits of memory, and we allocate it on the stack<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>. The procedure `cons` just returns the tagged pointer to this 128 bit span of memory. The tagged pointer itself is just the address of the pointers on the stack, with the last couple of bits flipped to the tag of a cons pair. Adding 3 to the memory address has the same effect.

So this:

    (cons 'a 'b) ;;=> ('a . 'b)

        .text
        .global cons
    cons:
     /* store frame pointer and return address on stack */
        stp x29, x30 [sp, #-16]!
     /* store stack pointer as new frame pointer */
        mov x29, [sp]
    
     /* store the arguments on the stack*/
        stp x0, x1 [sp, #-16]!
    
     /* <evaluation of arguments goes here>
      We'll put the pointers to evaluated arguments
      in the same registers (x0, x1) as they came to us */
    
     /* Getting the tagged pointer to our cons pair:
        We add 32 to the stack pointerto get the address
        of our cons pair and add 3 to flip the last two
        bits to #b011. Hence, we add 35.*/
        add x0, [sp], #35
    
     /* get back frame pointer and return address */
        ldp x29, x30, [sp], #32
        ret /* return to point in x30 */


# car (α)

The car is the first object in your cons-pair. Like so:

    (car ('a . 'b)) ;;=> 'a

The procedure for `car` should return the pointer stored in the first 64 bits of the cons-pair&rsquo;s memory address. Remember, this address is just the value of the tagged pointer, minus the tag itself.

        .text
        .global car
    car:
     /* store frame pointer and return address on stack */
        stp x29, x30 [sp, #-16]!
     /* store stack pointer as new frame pointer */
        mov x29, [sp]
    
      /* <evaluation of arguments goes here>
        We'll put the pointers to evaluated arguments
        in the same register x0 as they came to us.
        This is also where we would check the tag of
        the pointer given to us in x0, to make sure it
        points to a cons pair.*/
    
     /* First we subtract the tagged pointer of cons pair
        in order to get the memory address of the cons-pair.
        Then we load the value stored at that address into x0. */
        sub x0, x0, #3
        ldr x0, x0
    
     /* get back frame pointer and return address */
        ldp x29, x30, [sp], #16
        ret /* return to point in x30 */

Now if you read that, beyond all the boilderplate, it&rsquo;s just `sub x0, x0, #3` which removes the tag telling us the address is to a cons-pair, and `ldr x0, x0` which loads the return value into `x0`. We don&rsquo;t even bother storing the argument to `car` on the stack. `cdr` is similar:


# cdr (ω)

The cdr of a cons-pair is the second object stored in a cons-pair. Hence, `cdr` returns the second pointer stored in the 128 bits of a cons-pair in memory.
So this:

    (cdr ('a . 'b)) ;;=> 'b

Becomes this:

        .text
        .global cdr
    cdr:
     /* store frame pointer and return address on stack */
        stp x29, x30 [sp, #-16]!
     /* store stack pointer as new frame pointer */
        mov x29, [sp]
    
      /* <evaluation of arguments goes here>
        We'll put the pointers to evaluated arguments
        in the same register x0 as they came to us.
        This is also where we would check the tag of
        the pointer given to us in x0, to make sure it
        points to a cons pair.*/
    
     /* We'd subtract 3 from the tagged pointer to get the
        memory address of the cons-pair, then we'd add 8 to get
        the address of the second value. So we add 5.*/
        add x0, x0, #5
        ldr x0, x0
    
     /* get back frame pointer and return address */
        ldp x29, x30, [sp], #16
        ret /* return to point in x30 */

As I said, similar.


# nil (∅) and true (⊤)

In accord with the boolean pointer tagging we defined earlier:

-   `true (⊤)` is defined as `#b1010`
-   `nil (∅)` is defined as `#b0010`


# eq (=)

Equality in lisp is a problem full of pitfalls, and we are in too early a stage to actually approach it. As such, for our purposes, equality consists of no more than a comparison of two pointers. Remember, this is a preliminary lisp, an assembly lisp if you will. We&rsquo;re just trying to get to a better low-level language than assembly.

Taking only the case of two arguments, we can use something along these lines:

        .text
        .global eq
    eq:
     /* store frame pointer and return address on stack */
        stp x29, x30 [sp, #-16]!
     /* store stack pointer as new frame pointer */
        mov x29, [sp]
     /* store the arguments on the stack*/
        stp x0, x1 [sp, #-16]!
    
      /* <evaluation of arguments goes here>
        We'll put the pointers to evaluated arguments
        in the same register x0 as they came to us.
        This is also where we would check the tag of
        the pointer given to us in x0, to make sure it
        points to a cons pair.*/
    
        cmp x0, x1 /* this sets a condition flag */
        moveq x0, #10 /* conditional set x0 to #b1010 if equal */
        movnq x0 #2 /* conditional set x0 to #b0010 if not equal */
    
     /* get back frame pointer and return address */
        ldp x29, x30, [sp], #16
        ret /* return to point in x30 */


# cond (χ)

        .text
        .global eq
    eq:
     /* store frame pointer and return address on stack */
        stp x29, x30 [sp, #-16]!
     /* store stack pointer as new frame pointer */
        mov x29, [sp]
     /* store the arguments on the stack*/
        stp x0, x1 [sp, #-16]!
    
      /* <evaluation of arguments goes here>
        We'll put the pointers to evaluated arguments
        in the same register x0 as they came to us.
        This is also where we would check the tag of
        the pointer given to us in x0, to make sure it
        points to a cons pair.*/
    
        cmp x0, x1 /* this sets a condition flag */
        moveq x0, #10 /* conditional set x0 to #b1010 if equal */
        movnq x0 #2 /* conditional set x0 to #b0010 if not equal */
    
     /* get back frame pointer and return address */
        ldp x29, x30, [sp], #16
        ret /* return to point in x30 */


# Footnotes

<sup><a id="fn.1" href="#fnr.1">1</a></sup> (Thanks to Andres Raba for his version of SICP and for these figures!). Now, if we look at that, it becomes pretty clear what exactly that diagram actually represents:

<sup><a id="fn.2" href="#fnr.2">2</a></sup> We&rsquo;re not going to worry about memory allocation right now, or heaps and stacks, (although Henry Baker has some [interesting](https://dl.acm.org/doi/pdf/10.1145/130854.130858) [things](https://dl.acm.org/doi/pdf/10.1145/214448.214454) to say on the matter). Why? Because it&rsquo;s a big topic that I&rsquo;m not ready to approach. I do have some ideas, and it has ramifications to what we&rsquo;re going to do in this post, but suffice to say: where we&rsquo;re going, we don&rsquo;t need heaps!
